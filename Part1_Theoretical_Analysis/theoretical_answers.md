# Part 1 â€” Theoretical Analysis

## Q1: How AI-driven code generation tools reduce development time & limitations

**How they reduce development time**
- Auto-complete large code blocks and boilerplate.
- Suggest APIs and example usage while coding.
- Speed up prototyping and initial implementations.
- Provide quick fixes and refactoring suggestions.

**Limitations**
- May generate incorrect or insecure code.
- Can be non-optimal or poorly structured.
- Risk of over-reliance and reduced human review.
- Struggles with deep domain knowledge or complex logic.

---

## Q2: Supervised vs Unsupervised learning for automated bug detection

**Supervised learning**
- Uses labeled examples (bug / no-bug).
- Good at detecting known bug types.
- Example methods: classifiers (SVM, RandomForest).

**Unsupervised learning**
- Uses unlabeled data to find anomalies or clusters.
- Useful for discovering new/unknown bugs.
- Example methods: clustering, anomaly detection.

---

## Q3: Why bias mitigation is critical in personalization

- Personalized systems learn from historical data; biased data -> biased experiences.
- Unchecked bias can exclude or harm groups (unequal UX).
- Mitigation is essential for fairness, legal compliance, and user trust.

---

## Case Study: AIOps improvements in deployment efficiency

1. **Predictive detection:** ML models identify anomalies before deployment breaks systems.
2. **Automated remediation/rollback:** Automated actions (rollback, scaling) reduce downtime.

